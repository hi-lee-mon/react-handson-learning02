## ***第一級オブジェクト*** 
変数に格納・関数の引数に渡すことのできるオブジェクトのこと。
Javascriptにおいて関数は第一級オブジェクトにあたる。簡単に言えば関数は変数のように扱えるということになる。  
変数 = 第一級オブジェ クトと覚えればOK  
```
・変数への格納
・オブジェクトのバリュー
・配列の要素
・関数の引数
・関数の戻り値
```
## ***高階関数の定義*** 
「関数を引数として受け取っている」・「戻値として関数を返す」関数のこと

## ***関数型プログラミング言語*** 
関数を変数のように扱い、関数がアプリケーション内部を自由自在に行き来できる言語

## ***宣言型と命令型*** 
宣言型はwhat（何をするか？）を、命令型はhow（どのようにするか？）を記述してアプリケーションを構築する。  
宣言型はコードを見れば何がしたいかわかり、命令型はコメントなどを付けないとコードからは何をしたいか読み取れないのが特徴。  

## ***関数型プログラミングの基本概念*** 
* イミュータブル
* 純粋関数
* 配列によるイミュータブルデータの作成
* 高階関数
* 関数の合成
## `イミュータブルなデータ`
関数型ではすべてのデータはイミュータブルになる。  
ので、関数型プログラミングでデータに変更を加えるなら一度データをコピーしてコピーしたデータに対して変更を加える必要がある。  
スプレッド構文を利用すると簡単にイミュータブルなオブジェクトを作成することが出来る。  

## `純粋関数`
以下の特徴を持つ関数のこと
```
・少なくとも1つ以上の引数をとる
・値もしくは他の関数を返す
・引数をイミュータブルなデータとして扱う
・関数外で定義された値を直接変更してはいけない。
・グローバル変数の値によって挙動が変わらない
・同じ引数を受け取ったとき、必ず同じ戻り値を返す
```
以下を気を付ければ純粋関数が完成する
```
1. 引数有り
2. 戻り値有り
3. データはイミュータブルで扱う（関数型プログラミングの基本はイミュータブル）
```
純粋関数の例
```ts
const profile = {
    firstName: "taro",
    lastName: "sato",
    adult: false
  };

  type Profile = typeof profile;

  const check = (profile: Profile) => ({
    ...profile,
    adult: true
  });

  console.log(check(profile)); // => {firstName: "taro", lastName: "sato", adult: true}
  console.log(profile); // => {firstName: "taro", lastName: "sato", adult: false}
```

## `ReactのUIコンポーネント`
UIコンポーネントは純粋関数となっている。  
```
・少なくとも1つ以上の引数をとる
  props
・値もしくは他の関数を返す
  jsxを変換したReact要素
・引数をイミュータブルなデータとして扱う
  propsを直接変更することは禁止
・純粋関数の外側への影響がない（関数外の変数の値を変更したりしない）
  props以外の値へのアクセスはできないようになっている。
```

## `純粋関数はなぜテストが簡単なのか？`
純粋関数は引数の値しか見ていないため、引数をコントロールさえできればよいから。


## `純粋関数によるデータ変換`
mapやreducer・join・filterなどが純粋関数に当たる。

* filter関数  
配列から特定の要素を削除する際に利用する。
```ts
  const arr = ["aka", "ika", "azia", "ei", "usi", "aki"];
  const aArray = arr.filter((index) => index[1] === "k");
  console.log(aArray);
```
* map関数  
配列から新たな配列を作るときに利用する。  
指定の要素を書き換えることもできる。  

* Object.keys関数とmap関数  
オブジェクトのkey/valueからなる配列を作る
```ts

  const obj = {
    tokyo: 100,
    nagoya: 20,
    osaka: 200
  };
  const newObj = Object.keys(obj).map((key) => {
    return { name: key, value: obj[key] };
    // obj[key]はobj["tokyo"]と同じ
  });
  console.log(newObj);
```
* reduce関数  
最大値の探索・合計値・{}や[]の合体・要素の重複を取り除く
```ts
/**
 * reduce(コールバック関数, 初期値);
 * コールバック関数(初期値=>前回のreturn値, 現在の要素)
 *
 * ※reduceの第2引数は省略可能で、省略するとindex0が入る
 * 下記の例だと65が初期値となる。
 */
   const arr = [1, 20, 30, 45, 10, 3, 40, 1, 60];
  const newArr = arr.reduce((max, age) => (max > age ? max : age));
  console.log(newArr);
```
* reduceRight  
reduceRightはreduceとほとんど同じで異なる点としては配列を末尾から走査する。

## ***高階関数*** 
## `カリー化`
```ts
const add = (a) => (b) => a + b;
add(1)(2) // => 3

// 1. add(1)が実行される
// 2. const add = (1) => (b) => 1 + b;
// const add = (1) => { return (b) => {1 + b} }
// addの中に (b) => 1 + b という関数が返る
// 3. add(b)が実行される
// 4. const add = (2) => 1 + 2;
// 5 結果3になる
```

## ***再帰*** 
関数の中で自分自身を再帰的に呼び出すテクニック。  
非同期の中で処理を待った結果行いたい処理を書くときに便利。  
```ts
const countdown = (value, fn, delay = 1000) => {
  fn(value);
  return value > 0
    ? setTimeout(() => countdown(value - 1, fn, delay), delay)
    : value;
};

countdown(10, setCount);
```
## ***関数の合成*** 
カリー化が難しかった。今後勉強していく。
関数型プログラミングは関数を組み合わせてアプリケーションを作るのが基本なので
そんな感じの話とreduceやカリー化による部分適用などの話だった。
あんまり使いどころはないようなので（効果は短く書けるとか）勉強は後回しでも良いと思う。